# java 内存区域解析

java 内存区域主要分为五部分：
- 程序计数器（PC）
- 虚拟机栈(JVM Stack)
- 本地方法栈(Native Method Stack)
- Java 堆内存(Java Heap)
- 方法区(Method Area)

![image](http://osm01olbb.bkt.clouddn.com/github.com/jvmjvm-memory.png-github)

### 程序计数器
CPU内部的寄存器中就包含一个程序计数器，存放程序执行的下一条指令地址。在程序开始执行前，将程序指令序列的起始地址，即程序的第一条指令所在的内存单元地址送入PC.
CPU按照PC的地址从内存中读取第一条指令。每一条指令执行时，CPU会自动修改PC的量至下一条指令的地址，指令之间的跳转离不开PC。JVM内存中的程序计数器也是这样的作用，它储存JVM当前执行bytecode的地址。

### java虚拟机栈
java 虚拟机栈是线程私有的，每一条线程都拥有自己私有的Java 虚拟机栈，它与线程同时创建。<br>
***它描述了Java方法执行的内存模型：***
Java虚拟机栈也是线程私有的，每一条线程都拥有自己私有的Java 虚拟机栈，它与线程同时创建。它描述了Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至完成的过程，都对应一个栈帧从入栈到出栈的过程。
Java 虚拟机栈在方法调用和返回中也扮演了很重要的角色。因为除了栈帧的入栈和出栈之外，Java虚拟机栈不会再受其它因素的影响，因此栈帧可在系统的堆上分配内存（注意，是系统的Heap而不是Java Heap）。Java虚拟机栈所使用的内存不需要保证是连续的。

### 本地方法栈
本地方法栈和Java虚拟机栈的作用相似，Java虚拟机栈执行的是字节码，而本地方法栈执行的是native方法。本地方法栈使用传统的栈（C Stack）来支持native方法。在HotSpot JVM中Java虚拟机栈和本地方法栈合二为一。

### JAVA 堆
在JVM中，Java 堆是可供***各线程共享的运行时内存区域***，是Java 虚拟机所管理的内存区域中最大的一块.是Java 虚拟机所管理的内存区域中最大的一块。此区域非常重要，几乎所有的对象实例和数组实例都要在Java堆上分配，也可能会被优化为栈上分配。同时，Java 堆也是发生GC收集的主要区域。
Java堆的容量可以是固定的，也可以随着需要来扩展，并且在用不到的时候自动收缩。

### 方法区
方法区是线程共享的，它储存了每一个类的结构信息，比如运行时常量池（runtime constant pool）、字段和方法数据、构造函数和普通方法的字节码内容，还包括一些初始化的时候用到的特殊方法。方法区是堆的逻辑部分。

### 运行时常量池
运行时常量池是class文件中每一个类或接口的常量池表的运行时表示形式，是方法区的一部分。它包括了若干种不同的常量。常量池表存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。运行时常量池具有动态性，运行期间也可以将新的量放到运行时常量池中。
